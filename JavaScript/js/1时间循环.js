// js是单线程,其任务分为同步和异步两种.同步任务是按顺序执行的,异步则是不连续的可以先执行后面任务,等前面任务执行结果之后再执行任务一的回调.

// 在开发中像读取文件和网络请求这种比较耗时的通常属于异步任务,中间过程不需要js引擎可以自己完成.对于单线程的js来说不允许异步粪污返回之前的空白时间白白浪费.因此采用了 异步任务回调通知  的模式. 因此js的执行是在等待异步任务的同时,js引擎去执行其他的同步任务,等到异步任务准备好了,再去执行回调,这种模式也被称为非阻塞的的方式.  实现这种通知的,是时间循环, 把异步任务的回调部分交给事件循环, 等时机合适再交给js线程执行. 事件循环是JavaScript学习的计算机的一种的运行机制, 事件循环是有一个队列组成的,异步任务的回调先进先出,在js引擎空闲的时候一轮一轮取出,所以叫事件循环.  根据队列中的任务不同,分为宏任务和微任务.

// 事件循环是由宏任务和在执行宏任务期间产生的微任务组成,完成当下的宏任务之后,会立即执行所有在此期间入队的微任务.而这种设计是为了给紧急任务一个插队的机会,否则新入队的任务永远在队尾.区分了微任务和宏任务后,本轮循环中的微任务就是在插队,这样微任务中所做的状态的修改,在下一轮时间循环中也能得到同步.

//常见的宏任务有:script(整体代码)/settimout/setInterval/setImmediate(node)/requestAnimationFrame(浏览器独有)/IO/UI render(浏览器独有)
//常见的微任务有:process.nextTick(node独有)/promise.then()/Object.observe/MutationObserver

//setTimeout的回调不一定在指定之间后能执行,而是在指定时间后,将回调函数放入时间循环的队列中.如果时间到了,js引擎还在执行同步任务,这个回调就还需要等待;如果当前的事件循环队列中还有其他的回调,需要等其他回调执行完之后再执行本回调,setTimeout 0ms也不是立刻执行,会有一个默认的最小时间,4ms


//在整个浏览器的事件循环中,后弦执行第一个宏任务:全局的script脚本.产生的宏任务和微任务进入各自的队列.执行完script之后.把当前的微任务队列清空,完成一次事件循环.然后去执行宏任务
console.log('同步代码1');
setTimeout(() => {
    console.log('setTimeout')
}, 0)
new Promise((resolve) => {
  console.log('同步代码2')
  resolve()
}).then(() => {
    console.log('promise.then')
})
console.log('同步代码3');
// 最终输出"同步代码1"、"同步代码2"、"同步代码3"、"promise.then"、"setTimeout"
// promise.then为微任务队列, setTimeout为宏任务队列
